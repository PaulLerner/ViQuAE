{
  "trainee": {
    "class_name": "BiEncoder",
    "question_class": "IntermediateLinearFusion",
    "dpr_question_model_name_or_path": "experiments/ict/ilf/checkpoint-15600/question_model",
    "dpr_context_model_name_or_path": "experiments/ict/ilf/checkpoint-15600/context_model"
  },
  "trainer_class": "MMTrainer",
  "tokenizer": {
    "class_name": "BertTokenizer",
    "pretrained_model_name_or_path": "bert-base-uncased"
  },
  "verbosity": 10,
  "freeze": null,
    "train_dataset": "data/viquae_dataset/train",
    "eval_dataset": "data/viquae_dataset/validation",
  "metric": "retrieval",
    "kb": "data/viquae_passages",
    "image_kb": "data/viquae_wikipedia",
  "M": 2,
  "n_relevant_passages": 1,
  "search_key": "search",
  "tokenization_kwargs": {
    "max_length": 256,
    "padding": "longest"
  },
  "checkpoint": {
    "resume_from_checkpoint": null
  },
  "callbacks_args": [
    {
      "Class": "EarlyStoppingCallback",
      "early_stopping_patience": 100
    }
  ],
  "training_kwargs": {
    "do_train": true,
    "do_eval": false,
    "do_predict": false,
    "group_by_length": false,
    "output_dir": "experiments/mm/ilf",
    "logging_dir": "experiments/mm/ilf/",
    "evaluation_strategy": "steps",
    "prediction_loss_only": false,
    "per_device_train_batch_size": 298,
    "per_device_eval_batch_size": 625,
    "gradient_accumulation_steps": 1,
    "eval_accumulation_steps": 1,
    "max_grad_norm": 2.0,
    "num_train_epochs": 20,
    "learning_rate": 2e-05,
    "weight_decay": 0.0,
        "lr_scheduler_type": "linear",
        "warmup_steps": 4,
        "eval_steps": 4,
        "logging_steps": 4,
        "save_steps": 4,
        "gradient_checkpointing": true,
    "logging_strategy": "steps",
    "save_strategy": "steps",
    "dataloader_num_workers": 0,
    "dataloader_pin_memory": true,
    "adam_beta1": 0.9,
    "adam_beta2": 0.999,
    "adam_epsilon": 1e-8,
    "local_rank": -1,
    "ignore_data_skip": true,
    "remove_unused_columns": false,
    "greater_is_better": true,
    "load_best_model_at_end": true,
    "metric_for_best_model": "eval_MRR@N*M",
    "report_to": "tensorboard",
    "label_names": [
      "labels"
    ]
  }
}
